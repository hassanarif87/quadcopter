import numpy as np
from transforms3d import quaternions, euler

euler = euler.EulerFuncs('rxyz')
class PIDController:
    def __init__(self, dt, p_gain, i_gain = 0, d_gain = 0, sat=None, name = 'default'):
        self.name = name
        self.dt = dt
        self.p_gain = p_gain
        self.i_gain = i_gain
        self.d_gain = d_gain
        self.sat = sat
        self.integrated_error = 0.
        self.prev_error = 0.
    def update(self, sp, fb):
        """Update gains

        Args:
            sp (float): reference signal Set point
            fb (float): Sensor Feedback

        Returns:
            output (float): command signal

        """
        dt = self.dt
        error = sp - fb
        self.integrated_error = self.integrated_error + (self.prev_error + error) / 2 * dt
        p_term = self.p_gain * (error)
        i_term =self.i_gain * (self.integrated_error)
        d_term = self.d_gain * (error - self.prev_error) / dt
        output = p_term + i_term + d_term
        self.prev_error = error
        if (self.sat is not None):
            # set Saturation
            output = min(output, self.sat)
            output = max(output, -self.sat)
        return output

    @property
    def reset_integral(self):
        self.integrated_error = 0


def quar_axis_error(q_sp, q_state):
    """Compute the error in quaternions from the setpoints and robot state

    Args:
        q_sp (np.array): Reference signal Set point quaternion
        q_state (np.array): Sensor Feedback quaternion
    Returns:
        exponential angle (np.array)
    """

    # Quaternion multiplication q_set * (q_state)' target - state

    q_state_conj = quaternions.qconjugate(q_state)
    q_error =  quaternions.qmult(q_sp,q_state_conj)

    # Nearest rotation
    if (q_error[0] < 0):
        q_error = -1. * q_error

    axis_error = quaternions.quat2axangle(q_error)
    return axis_error[0] * axis_error[1]

def thrust_tilt(eulAng,PWM_hover):

    phi = eulAng[0,0] # Roll
    theta = eulAng[1,0] # Pitch
    psi =  eulAng[2,0]
    scaling = 1./(abs(np.sqrt(np.cos(phi)*np.cos(theta))))
    scaling = min (scaling, 1.3)
    return PWM_hover*scaling


class FlightComputer:
    def __init__(self, dt, fc_config):
        gains = fc_config['gains']
        self.roll_controller = PIDController(dt, gains['Kp_roll'], sat= gains['PR_SAT'], name='Roll')
        self.pitch_controller = PIDController(dt, gains['Kp_pitch'], sat = gains['PR_SAT'], name='Pitch')
        self.yaw_controller = PIDController(dt, gains['Kp_yaw'], name='Yaw')
        self.alt_controller = PIDController(dt, gains['Kp_vzSAT'], sat = gains['Kp_vzSAT'], name='Alt')
        self.p_controller = PIDController(dt,gains['Kp_p'], name='p')
        self.q_controller = PIDController(dt,gains['Kp_q'], name='q')
        self.r_controller = PIDController(dt,gains['Kp_r'], name='r')
        self.u2motor = fc_config["cmd2motor_map"]
        self.esc_min = fc_config["esc_settings"]["Saturation"][0]
        self.esc_max = fc_config["esc_settings"]["Saturation"][1]

        self.PWM_hover = None

    def target_generator(self,eulAngSP):
        # Temp solution to get sp, should would be generated by guidance
        q_sp = euler.euler2quat(eulAngSP[0], eulAngSP[1], eulAngSP[2]) # XYZ
        vzSP = 0
        return q_sp, vzSP

    def update (self, sensor_data, eulAngSP):
        vz = sensor_data['vz']
        q_state = sensor_data['q_state']
        p = sensor_data['p']
        q = sensor_data['q']
        r = sensor_data['r']
        eulAng = sensor_data['eulAng']
        rateSP = np.zeros(3)

        q_sp, vzSP =  self.target_generator(eulAngSP)
        ## Calculating quartenion error

        axis_error = quar_axis_error(q_sp,q_state)
        ## Cascade PID
        rateSP[0] = self.roll_controller.update(axis_error[0], 0.)
        rateSP[1] = self.pitch_controller.update(axis_error[1], 0.)
        rateSP[2] = self.yaw_controller.update(axis_error[2], 0.)
        u = np.zeros(4)
        u[0] = thrust_tilt(eulAng, self.PWM_hover[0]) -self.alt_controller.update(vzSP, vz)
        u[1] = self.p_controller.update(rateSP[0], p)
        u[2] = self.q_controller.update(rateSP[1], q)
        u[3] = self.r_controller.update(rateSP[2], r)

        ## ESC ##
        PWM = np.dot(self.u2motor,u)
        # ESC Saturation
        for val in range(0, 4):
            PWM[val] = min(PWM[val], self.esc_max)
            PWM[val] = max(PWM[val], self.esc_min)

        log  = [eulAng, eulAngSP, u, PWM, rateSP]
        return PWM, log